# Android-State

A utility library for Android to save objects in a `Bundle` without any boilerplate. It uses an annotation processor to wire up all dependencies.

## Download

Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evernote"%20AND%20a:"android-state") or grab via Gradle:

```groovy
dependencies {
    compile 'com.evernote:android-state:0.0.1'
    annotationProcessor 'com.evernote:android-state-processor:0.0.1'
}
```

You can read the [JavaDoc here](https://evernote.github.io/android-state/javadoc/).

## Usage

Annotate any field with `@State` and use the `StateSaver` class to save those fields in a Bundle. This works from an `Activity` or `Fragment`, but also from anywhere else in your code. You can save any type which can be saved in a Bundle like `String`s, `Serializable`s and `Parcelable`s.

```java
public class MainActivity extends Activity {

    @State
    public int mValue;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        StateSaver.restoreInstanceState(this, savedInstanceState);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        StateSaver.saveInstanceState(this, outState);
    }
}
```

## Advanced

You can also save the state in a `View` class.

```java
public class TestView extends View {

    @State
    public int mState;

    public TestView(Context context) {
        super(context);
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        return StateSaver.saveInstanceState(this, super.onSaveInstanceState());
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        super.onRestoreInstanceState(StateSaver.restoreInstanceState(this, state));
    }
}
```

Fields must not be `private`. If a property is `private`, then a non-private getter and setter method are required. This is especially useful for Kotlin, because properties are `private` by default and the methods are generated by the compiler.

```kotlin
class DemoPresenter : Presenter<DemoView>() {

    @State
    var counter = 0

    // ...
}

```

Of course, this also works in Java.

```java
public class TitleUpdater {

    @State
    private String mTitle;

    public String getTitle() {
        return mTitle;
    }

    public void setTitle(String title) {
        mTitle = title;
    }
}
```

If you also don't want to provide a getter or setter method, then you can fallback to reflection. However, this is not the recommended way.

```java
public class ImageProcessor {

    @State(reflection = true)
    private byte[] mImageData;

    // ...
}
```

A custom bundler can be useful, if any class doesn't implement the `Parcelable` or `Serializable` interface, e.g. that often happens with third party dependencies.

```java
public class MappingProvider {

    @State(PairBundler.class)
    public Pair<String, Integer> mMapping;

    public static final class PairBundler implements Bundler<Pair<String, Integer>> {
        @Override
        public void put(@NonNull String key, @NonNull Pair<String, Integer> value, @NonNull Bundle bundle) {
            bundle.putString(key + "first", value.first);
            bundle.putInt(key + "second", value.second);
        }

        @Nullable
        @Override
        public Pair<String, Integer> get(@NonNull String key, @NonNull Bundle bundle) {
            if (bundle.containsKey(key + "first")) {
                return new Pair<>(bundle.getString(key + "first"), bundle.getInt(key + "second"));
            } else {
                return null;
            }
        }
    }
}
```

#### Proguard

The library comes with a proguard config. No steps are required, but just in case all necessary rules can be found [here](library/proguard.cfg).

## [Icepick](https://github.com/frankiesardo/icepick)

You can easily see that the origin of this library is [Icepick](https://github.com/frankiesardo/icepick), a great library from Frankie Sardo. However, it misses some important features for us, e.g. it [doesn't support properties](https://github.com/frankiesardo/icepick/issues/81) which is a [bummer for Kotlin](https://github.com/frankiesardo/icepick/issues/47). Also that non-private fields aren't allowed can break encapsulation. A tool shouldn't force you into this direction.

Since Icepick is implemented in Clojure, we decided that's it's better for us to rewrite the annotation processor in Java. Unfortunately, that makes it hard to push our features into Icepick itself. That's why we decided to fork the project.

There are also alternatives for Kotlin like [IceKick](https://github.com/tinsukE/icekick). However, for us it wasn't comfortable to have two different working tools doing the same thing. We wanted to have one solution for all scenarios.

Upgrading to this library from Icepick is easy. The API is the same, only the packages and the class name from `Icepick` to `StateSaver` have changed. If Icepick works well for you, then there's no need to upgrade.

## License

    Copyright (c) 2007-2017 by Evernote Corporation, All rights reserved.

    Use of the source code and binary libraries included in this package
    is permitted under the following terms:

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
